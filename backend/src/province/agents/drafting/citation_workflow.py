"""
Citation Insertion and Validation Workflow

This module provides automated citation insertion and validation
for legal documents generated by the drafting agent.
"""

import re
import json
import logging
import requests
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

logger = logging.getLogger(__name__)


class CitationType(Enum):
    """Types of legal citations"""
    CASE_LAW = "case_law"
    STATUTE = "statute"
    REGULATION = "regulation"
    CONSTITUTIONAL = "constitutional"
    SECONDARY_AUTHORITY = "secondary_authority"
    UNKNOWN = "unknown"


@dataclass
class Citation:
    """Represents a legal citation"""
    text: str
    citation_type: CitationType
    components: Dict[str, str]
    position: Tuple[int, int]  # Start and end positions in text
    is_valid: bool = False
    validation_score: float = 0.0
    validation_notes: List[str] = None
    suggested_correction: Optional[str] = None
    
    def __post_init__(self):
        if self.validation_notes is None:
            self.validation_notes = []


@dataclass
class CitationValidationResult:
    """Result of citation validation"""
    original_text: str
    citations_found: List[Citation]
    validation_summary: Dict[str, Any]
    corrected_text: str
    confidence_score: float


class CitationWorkflow:
    """
    Manages citation insertion and validation workflow for legal documents
    """
    
    def __init__(self):
        self.citation_patterns = self._initialize_citation_patterns()
        self.validation_cache = {}  # Cache for validation results
        
    def _initialize_citation_patterns(self) -> Dict[CitationType, List[str]]:
        """Initialize regex patterns for different citation types"""
        
        return {
            CitationType.CASE_LAW: [
                # Federal cases: 123 F.3d 456 (9th Cir. 2020)
                r'(\d+)\s+F\.\s*(?:2d|3d)?\s+(\d+)\s*\(([^)]+)\s+(\d{4})\)',
                # Supreme Court: 123 U.S. 456 (2020)
                r'(\d+)\s+U\.S\.\s+(\d+)\s*\((\d{4})\)',
                # State cases: 123 Cal. App. 4th 456 (2020)
                r'(\d+)\s+([A-Za-z\.]+)\s+(?:App\.\s+)?(?:\d+[a-z]+\s+)?(\d+)\s*\((\d{4})\)'
            ],
            CitationType.STATUTE: [
                # Federal statutes: 42 U.S.C. § 1983
                r'(\d+)\s+U\.S\.C\.\s*§\s*(\d+(?:\([a-z0-9]+\))?)',
                # State statutes: Cal. Civ. Code § 1234
                r'([A-Za-z\.]+)\s+([A-Za-z\.]+)\s+Code\s*§\s*(\d+(?:\.[a-z0-9]+)?)'
            ],
            CitationType.REGULATION: [
                # CFR: 29 C.F.R. § 1630.2
                r'(\d+)\s+C\.F\.R\.\s*§\s*(\d+\.\d+)',
                # Federal Register: 85 Fed. Reg. 12345
                r'(\d+)\s+Fed\.\s*Reg\.\s+(\d+)'
            ],
            CitationType.CONSTITUTIONAL: [
                # U.S. Constitution: U.S. Const. art. I, § 8
                r'U\.S\.\s+Const\.\s+art\.\s+([IVX]+),?\s*§\s*(\d+)',
                # Amendments: U.S. Const. amend. XIV
                r'U\.S\.\s+Const\.\s+amend\.\s+([IVX]+)'
            ]
        }
    
    def extract_citations(self, text: str) -> List[Citation]:
        """
        Extract all citations from text
        
        Args:
            text: Text to extract citations from
            
        Returns:
            List of Citation objects found in the text
        """
        citations = []
        
        for citation_type, patterns in self.citation_patterns.items():
            for pattern in patterns:
                matches = re.finditer(pattern, text, re.IGNORECASE)
                
                for match in matches:
                    citation = Citation(
                        text=match.group(0),
                        citation_type=citation_type,
                        components=self._parse_citation_components(match, citation_type),
                        position=(match.start(), match.end())
                    )
                    citations.append(citation)
        
        # Sort citations by position in text
        citations.sort(key=lambda c: c.position[0])
        
        return citations
    
    def _parse_citation_components(self, match: re.Match, citation_type: CitationType) -> Dict[str, str]:
        """Parse citation components based on type"""
        
        components = {}
        groups = match.groups()
        
        if citation_type == CitationType.CASE_LAW:
            if len(groups) >= 4:
                components = {
                    'volume': groups[0],
                    'reporter': groups[1] if 'F.' in match.group(0) else 'U.S.',
                    'page': groups[1] if 'U.S.' in match.group(0) else groups[2],
                    'court': groups[2] if 'F.' in match.group(0) else '',
                    'year': groups[3] if 'F.' in match.group(0) else groups[2]
                }
        elif citation_type == CitationType.STATUTE:
            if len(groups) >= 2:
                components = {
                    'title': groups[0],
                    'section': groups[1]
                }
        elif citation_type == CitationType.REGULATION:
            if len(groups) >= 2:
                components = {
                    'title': groups[0],
                    'section': groups[1]
                }
        
        return components
    
    def validate_citations(self, citations: List[Citation]) -> List[Citation]:
        """
        Validate a list of citations
        
        Args:
            citations: List of citations to validate
            
        Returns:
            List of citations with validation results
        """
        validated_citations = []
        
        for citation in citations:
            # Check cache first
            cache_key = f"{citation.citation_type.value}:{citation.text}"
            if cache_key in self.validation_cache:
                cached_result = self.validation_cache[cache_key]
                citation.is_valid = cached_result['is_valid']
                citation.validation_score = cached_result['validation_score']
                citation.validation_notes = cached_result['validation_notes']
                citation.suggested_correction = cached_result.get('suggested_correction')
            else:
                # Perform validation
                self._validate_single_citation(citation)
                
                # Cache the result
                self.validation_cache[cache_key] = {
                    'is_valid': citation.is_valid,
                    'validation_score': citation.validation_score,
                    'validation_notes': citation.validation_notes,
                    'suggested_correction': citation.suggested_correction
                }
            
            validated_citations.append(citation)
        
        return validated_citations
    
    def _validate_single_citation(self, citation: Citation):
        """Validate a single citation"""
        
        validation_score = 0.0
        validation_notes = []
        
        # Format validation
        format_score = self._validate_citation_format(citation)
        validation_score += format_score * 0.4
        
        if format_score < 0.8:
            validation_notes.append("Citation format may not follow standard conventions")
        
        # Content validation (external lookup)
        content_score = self._validate_citation_content(citation)
        validation_score += content_score * 0.6
        
        if content_score < 0.5:
            validation_notes.append("Citation could not be verified in external databases")
        elif content_score < 0.8:
            validation_notes.append("Citation verification returned partial matches")
        
        # Update citation with validation results
        citation.validation_score = validation_score
        citation.is_valid = validation_score >= 0.7
        citation.validation_notes = validation_notes
        
        # Generate correction suggestion if needed
        if not citation.is_valid:
            citation.suggested_correction = self._suggest_citation_correction(citation)
    
    def _validate_citation_format(self, citation: Citation) -> float:
        """Validate citation format according to Bluebook rules"""
        
        score = 1.0
        text = citation.text
        
        # Check for common format issues
        if citation.citation_type == CitationType.CASE_LAW:
            # Check for proper spacing
            if '  ' in text:  # Double spaces
                score -= 0.1
            
            # Check for proper abbreviations
            if 'F.3d' not in text and 'F.2d' not in text and 'U.S.' not in text:
                score -= 0.2
            
            # Check for parentheses around court and year
            if not re.search(r'\([^)]+\d{4}\)', text):
                score -= 0.3
        
        elif citation.citation_type == CitationType.STATUTE:
            # Check for proper section symbol
            if '§' not in text and 'Section' not in text:
                score -= 0.2
            
            # Check for proper abbreviation
            if 'U.S.C.' not in text and 'Code' not in text:
                score -= 0.2
        
        return max(score, 0.0)
    
    def _validate_citation_content(self, citation: Citation) -> float:
        """Validate citation content against external databases"""
        
        try:
            # Try CourtListener for case law
            if citation.citation_type == CitationType.CASE_LAW:
                return self._check_courtlistener(citation)
            
            # For statutes, check basic format validity
            elif citation.citation_type == CitationType.STATUTE:
                return self._check_statute_validity(citation)
            
            # For regulations, check CFR structure
            elif citation.citation_type == CitationType.REGULATION:
                return self._check_regulation_validity(citation)
            
            # Default validation for other types
            return 0.5
            
        except Exception as e:
            logger.warning(f"Citation validation error: {str(e)}")
            return 0.3  # Partial score if validation fails
    
    def _check_courtlistener(self, citation: Citation) -> float:
        """Check citation against CourtListener database"""
        
        try:
            # CourtListener API search
            api_url = "https://www.courtlistener.com/api/rest/v3/search/"
            params = {
                'q': citation.text,
                'type': 'o',  # Opinions
                'format': 'json'
            }
            
            response = requests.get(api_url, params=params, timeout=5)
            
            if response.status_code == 200:
                data = response.json()
                results = data.get('results', [])
                
                if len(results) > 0:
                    return 0.9  # High confidence if found
                else:
                    return 0.3  # Low confidence if not found
            else:
                return 0.5  # Medium confidence if API unavailable
                
        except Exception as e:
            logger.warning(f"CourtListener check failed: {str(e)}")
            return 0.5
    
    def _check_statute_validity(self, citation: Citation) -> float:
        """Check statute citation validity"""
        
        # Basic format checks for U.S.C. citations
        if 'U.S.C.' in citation.text:
            components = citation.components
            
            # Check if title number is reasonable (1-54 for U.S.C.)
            try:
                title = int(components.get('title', '0'))
                if 1 <= title <= 54:
                    return 0.8
                else:
                    return 0.4
            except ValueError:
                return 0.3
        
        # State statute format validation would go here
        return 0.6
    
    def _check_regulation_validity(self, citation: Citation) -> float:
        """Check regulation citation validity"""
        
        # Basic format checks for C.F.R. citations
        if 'C.F.R.' in citation.text:
            components = citation.components
            
            # Check if title number is reasonable (1-50 for C.F.R.)
            try:
                title = int(components.get('title', '0'))
                if 1 <= title <= 50:
                    return 0.8
                else:
                    return 0.4
            except ValueError:
                return 0.3
        
        return 0.6
    
    def _suggest_citation_correction(self, citation: Citation) -> Optional[str]:
        """Suggest a correction for an invalid citation"""
        
        text = citation.text
        
        # Common corrections
        corrections = {
            # Fix spacing issues
            r'(\d+)\s*F\s*\.?\s*(\d+[a-z]*)\s*(\d+)': r'\1 F.\2d \3',
            r'(\d+)\s*U\s*\.?\s*S\s*\.?\s*(\d+)': r'\1 U.S. \2',
            # Fix section symbols
            r'Section\s*(\d+)': r'§ \1',
            r'Sec\.\s*(\d+)': r'§ \1'
        }
        
        corrected_text = text
        for pattern, replacement in corrections.items():
            corrected_text = re.sub(pattern, replacement, corrected_text, flags=re.IGNORECASE)
        
        return corrected_text if corrected_text != text else None
    
    def insert_citations(self, text: str, citation_suggestions: List[Dict[str, Any]]) -> str:
        """
        Insert citations into text based on suggestions
        
        Args:
            text: Original text
            citation_suggestions: List of citation suggestions with positions
            
        Returns:
            Text with citations inserted
        """
        # Sort suggestions by position (reverse order to maintain positions)
        suggestions = sorted(citation_suggestions, key=lambda x: x.get('position', 0), reverse=True)
        
        modified_text = text
        
        for suggestion in suggestions:
            position = suggestion.get('position', len(modified_text))
            citation_text = suggestion.get('citation', '')
            
            if citation_text:
                # Insert citation at specified position
                modified_text = (
                    modified_text[:position] + 
                    f" {citation_text}" + 
                    modified_text[position:]
                )
        
        return modified_text
    
    def process_document(self, text: str, validate_existing: bool = True, 
                        insert_suggestions: List[Dict[str, Any]] = None) -> CitationValidationResult:
        """
        Complete citation processing workflow for a document
        
        Args:
            text: Document text to process
            validate_existing: Whether to validate existing citations
            insert_suggestions: New citations to insert
            
        Returns:
            CitationValidationResult with all processing results
        """
        # Extract existing citations
        existing_citations = self.extract_citations(text)
        
        # Validate existing citations if requested
        if validate_existing:
            existing_citations = self.validate_citations(existing_citations)
        
        # Insert new citations if provided
        corrected_text = text
        if insert_suggestions:
            corrected_text = self.insert_citations(text, insert_suggestions)
        
        # Calculate overall confidence score
        if existing_citations:
            avg_validation_score = sum(c.validation_score for c in existing_citations) / len(existing_citations)
        else:
            avg_validation_score = 1.0  # No citations to validate
        
        # Generate validation summary
        validation_summary = {
            'total_citations': len(existing_citations),
            'valid_citations': sum(1 for c in existing_citations if c.is_valid),
            'invalid_citations': sum(1 for c in existing_citations if not c.is_valid),
            'average_validation_score': avg_validation_score,
            'citation_types': {ct.value: sum(1 for c in existing_citations if c.citation_type == ct) 
                             for ct in CitationType},
            'validation_notes': [note for c in existing_citations for note in c.validation_notes]
        }
        
        return CitationValidationResult(
            original_text=text,
            citations_found=existing_citations,
            validation_summary=validation_summary,
            corrected_text=corrected_text,
            confidence_score=avg_validation_score
        )
    
    def get_citation_statistics(self, citations: List[Citation]) -> Dict[str, Any]:
        """Get statistics about citations"""
        
        if not citations:
            return {'total': 0}
        
        return {
            'total': len(citations),
            'by_type': {ct.value: sum(1 for c in citations if c.citation_type == ct) for ct in CitationType},
            'valid_count': sum(1 for c in citations if c.is_valid),
            'invalid_count': sum(1 for c in citations if not c.is_valid),
            'average_score': sum(c.validation_score for c in citations) / len(citations),
            'needs_correction': sum(1 for c in citations if c.suggested_correction)
        }